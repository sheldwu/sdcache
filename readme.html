
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
<title>DDcache &lt; Main &lt; TWiki</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="icon" href="/twiki/pub/Main/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="/twiki/pub/Main/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/twiki/bin/view.pl/Main/WebRss" />
<base href="http://twiki.dangdang.com/twiki/bin/view.pl/Main/DDcache"></base><!--/closing tag 'solves' IE selection bug-->
<script type="text/javascript" src="/twiki/pub/TWiki/TWikiJavascripts/twiki.js"></script>
<script type="text/javascript" src="/twiki/pub/TWiki/PatternSkin/pattern.js"></script>
<script type="text/javascript">
//<![CDATA[
    function launchWindow(inWeb, inTopic) {
        return launchTheWindow("/twiki/bin/view.pl/", inWeb, inTopic, "", "viewplain" );
    }
//]]>
</script>
<script type='text/javascript' src='/twiki/pub/TWiki/TwistyContrib/twist.js'></script>



<style type="text/css" media="all">
    @import url('/twiki/pub/TWiki/TwistyContrib/twist.css');
</style>
<style type="text/css" media="all">
    #patternTopBar,
#patternClearHeaderCenter,
#patternClearHeaderLeft,
#patternClearHeaderRight,
#patternTopBarContentsOuter {
    height:64px; /* top bar height; make room for header columns */
    overflow:hidden;
}
    #patternOuter {
    margin-left:12em;
}
#patternLeftBar {
    width:12em;
    margin-left:-12em;
}
</style>
<style type="text/css" media="all">
    @import url('/twiki/pub/TWiki/PatternSkin/layout.css');
    @import url('/twiki/pub/TWiki/PatternSkin/style.css');
    @import url('/twiki/pub/TWiki/PatternSkin/colors.css');
</style>

<style type="text/css" media="all">
    /* Styles that are set using variables */
    .twikiInputField {
        background-image:url("/twiki/pub/TWiki/PatternSkin/background_input.gif");
        background-repeat:repeat-x;
    }
    .twikiInputFieldDisabled {
        background-image:none;
        border:none;
    }
    .twikiButton {
        background-image:url("/twiki/pub/TWiki/PatternSkin/background_button.gif");
        background-repeat:repeat-x;
    }
    .patternToolBarButtons .patternButton a {
        /*
        background-image:url("/twiki/pub/TWiki/PatternSkin/background_button.gif");
        background-repeat:repeat-x;
        */
    }
    .twikiSubmit {
        background-image:url("/twiki/pub/TWiki/PatternSkin/background_submit.gif");
        background-repeat:repeat-x;
    }
    .twikiSubmitDisabled {
        background-image:none;
    }
    .twikiToc li {
        background-image:url("/twiki/pub/TWiki/PatternSkin/bullet-down.gif");
        background-repeat:no-repeat;
    }
    #patternLeftBar .patternWebIndicator,
    .patternBookView .twikiTopRow {
        background-color:#FFEFA6;
    }
    #patternTopBar { background-image:url("/twiki/pub/TWiki/PatternSkin/TWiki_header.gif"); background-repeat:no-repeat;}
    #patternTopBar { background-color:#ffffff;}
    /*
    .twikiHelp,
    .patternAccessKeyInfo {
        background:url("/twiki/pub/TWiki/PatternSkin/striped_blue.gif");
    }
    */
    .patternBookView {
        border-color:#FFEFA6;
    }
    #twikiLogin,
    #patternLeftBarContents .tipsOfTheDayContents {
        background-image:url("/twiki/pub/TWiki/PatternSkin/gradient_blue.gif");
        background-repeat:repeat-x;
    }
    #patternOuter {
        /* gradient yellow of left bar and main */
        background-image:url("/twiki/pub/TWiki/PatternSkin/gradient_yellow.gif");
        background-repeat:repeat-x;
    }
    .patternPrintPage #patternOuter {
        background:#fff;
    }
    .twikiPageForm table {
        background-image:url("/twiki/pub/TWiki/PatternSkin/form_gradient.gif");
        background-repeat:repeat-x;
    }
    #patternLeftBarContents .patternLeftBarPersonal li {
        background-image:url("/twiki/pub/TWiki/PatternSkin/bullet-blue.gif");
        background-repeat:no-repeat;
        background-position:0 .5em;
    }
    .patternPreviewPage #patternMain {
        background-image:url(/twiki/pub/TWiki/PreviewBackground/preview2bg.gif);
    }
    
</style>
<style type="text/css" media="all">
    
    
    
</style>

<style type="text/css" media="all">
    @import url("/twiki/pub/TWiki/PatternSkin/print.css");
</style>


</head>
<body class="patternViewPage"><a name="PageTop"></a>
<div id="patternScreen">
<div id="patternPageShadow">
<div id="patternPage">
<div id="patternWrapper"><div id="patternOuter">
<div id="patternFloatWrap">
<div id="patternMain"><div id="patternClearHeaderCenter"></div>
<div id="patternMainContents"><div class="patternTop">
<p />
<h2><a name="ddcache接口说明"></a> ddcache接口说明 </h2>
<p /> <ul>
<li> 之所以命名为ddcache完全是为了考虑当当特色，实际上叫urlCahe更为贴切，因为该项目的核心功能就是对用户的url进行缓存，以避免web服务器对相同url频繁的计算，减少web服务器压力，同时节约客户端的访问时间。ddcache基于http协议，单键值储存，最大可支持压缩后1M的数据，数据压缩是指目标网页将使用zlib.compress方法进行压缩，不要担心，解压工作ddcache已经在返回之前做完了。
</li></ul> 
<p /> <ul>
<li> ddcache使用无需安装，直接在你喜欢的目录下解压，make&amp;run。
</li></ul> 
<p /> <ul>
<li> ddcache使用http协议访问，参数简单，你只需要传入 <ul>
<li> url：     需要访问的目标url，请注意使用urlencode
</li></ul> 
</li> <li> debug参数 <ul>
<li> view:    当view=1时，将默认打印每个线程的等待队列情况，以方便对服务压力情况进行即时反馈。
</li> <li> debug: 当debug=1时，配合不同的url，将打印出不同线程目前的cache使用情况，目前没有提供统一打印的功能，即用户需要不断变换url来获取不同的线程内存使用情况，提供一份2，4，8个线程的table <ul>
<li>    * <table width="500" height = "200" border="1"><tr><td>线程数/线程号</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>2</td><td>2</td><td>1</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>4</td><td>2</td><td>1</td><td>9</td><td>0</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>8</td><td>48</td><td>18</td><td>6</td><td>0</td><td>2</td><td>1</td><td>8</td><td>76</td></tr></table>
</li> <li> debug信息示例:</br>             thread 7: bucket_num:524288</br>             value_size:3000</br>             slice_size:131072</br>             slice_count:1</br>             items: 0</br>             chunk_cnt:0</br>             free_cnt: 0</br>             max_size: 2048M</br>             alloc_size:381.000000M</br>             use_size:0.000000M
</li> <li> 说明 <ul>
<li> thread:          当前线程编号
</li> <li> bucket_num:  桶数
</li> <li> value_size:     当前设置的存储值最小单元（1 chunk，每个value由n(n&gt;=1)个chunk通过链表组成）
</li> <li> slice_size:      当前设置的每次分配chunk数
</li> <li> slice_count：  已经分配的slice数
</li> <li> items:            当前存储的item数
</li> <li> chunk_cnt：   当前已经使用的chunk个数
</li> <li> free_cnt：      free的chunk个数
</li> <li> max_size：     初始化的最大可使用空间
</li> <li> alloc_size:      已经分配的空间
</li> <li> use_size:       分配的空间中被使用的空间
</li></ul> 
</li></ul> 
</li></ul> 
</li></ul> 
<p />
<h2><a name="ddcache使用说明"></a> ddcache使用说明 </h2>
<h5><a name="第一步: 下载ddcache源码"></a> 第一步: 下载ddcache源码 </h5>
<p />
<code>wget 192.168.85.152:8011/ddcache.tar.gz</code>
<p />
<h5><a name="第二步: 解压ddcache.tar.gz"></a> 第二步: 解压ddcache.tar.gz </h5>
<p />
<code>tar -zxvf ddcache.tar.gz</code>
<p />
<h5><a name="第三步: 编译目标文件"></a> 第三步: 编译目标文件 </h5>
<p />
<code>cd ddcache/server; make</code>
<p />
<h5><a name="启动及停止kvcache"></a> 启动及停止kvcache </h5>
<p />
执行以下命令:
<p />
<code>ddcache -n 1 -p 8390 -e 6000&nbsp; -s 100 -m 2000 -b 1000 -k start&nbsp; -v 10000</code>
<p />
参数列表: <ul>
<li> -n thread_number: 线程数, 正整数, 不宜超过CPU核数
</li> <li> -p listening_port: 监听的端口号
</li> <li> -e expire_time: 缓存失效时间 （default:1Year）
</li> <li> -s slice_size:每片的大小，建议设置在与数据规模1/10左右（defalut:100000）
</li> <li> -m max_size:内存使用的最大限制,单位为M（default:2048M）
</li> <li> -b bucket_number: 桶数, 4至200000000之间的整数, 不宜过大过或过小, 以数据规模120%为宜. 过大会造成空间浪费, 过小则会降低存取速度.（default:120000 ）
</li> <li> -k start|stop|restart: start为启动, stop为停止,restart为重启
</li> <li> -v value_size：因ddcache数据存储采用分段切割存储，value_size为每段数据的大小，设置应该比数据集中长度区稍大一些（如数据长度热点是1000，则最好设置成1200），过小会导致数据切割过多，造成反复寻址，浪费时间，过大则空间浪费严重(default:1000)
</li></ul> 
<p />
<h2><a name="ddcache使用说明"></a> ddcache使用说明 </h2> <ul>
<li> ddcache是支持单键获取的缓存系统， 单键存取是指在插入数据时, ddcache在一次HTTP连接中接受一个键(url)，在返回数据时，首先在自身缓存池中查找，若没有命中，则从目标url自动获取并进行存储并返回给用户. 
</li> <li> 注意，若目标数据压缩后大于ddcache最大缓存长度，则该数据存储时会被抛弃，但仍可以正常返回，此时ddcache退化为代理
</li></ul> 
<p />
<h2><a name="ddcache输入输出说明"></a> ddcache输入输出说明 </h2>
kvcache的输入输出说明如下：
<h5><a name="1. 输入"></a> 1. 输入 </h5>有以下两点需要说明： <ul>
<li> 1.1 使用时一次只能访问一个url，并且该url必须进行urlencode. 
</li> <li> 1.2 url支持http协议，支持以下两种格式： <ul>
<li> a) <code>http://lcoalhost/a.html/?xxxx</code>
</li> <li> b) <code>localhost/?xxxx</code>
</li></ul> 
</li></ul> 
<p />
<h5><a name="2. 输出"></a> 2. 输出 </h5> <ul>
<li> 2.1 正确获得目标url <ul>
<li> ddcache不会对目标url做任何处理，将包括目标url头信息在内的所有数据原样通过http协议直接返回给用户。
</li></ul> 
</li> <li> 2.2 url获取失败 <ul>
<li> 返回url错误的信息给用户
</li></ul> 
</li></ul> 
<p />
<h2><a name="为什么使用ddcache而不是m"></a> <p style="color:green">为什么使用ddcache而不是memcache</p> </h2> <ul>
<li> 1.ddcache使用更简单，轻量级的应用删除了客户端的概念，如果你的配置文件是tart_url = abc.com，那么现在只需要改成tar_url = ddcache.com?url=abc.com，就可以方便的使用ddcache，没有客户端的概念，可以简单的ddcache当作代理缓存使用，只不过我们不在硬盘而是内存存储数据。
li></ul> 
</br> <ul>
<li> 2. memcache设计的多适应性，因此需要手动get,set键值对，而ddcache只是为url缓存设计，用户只需要get即可，若未命中，ddcache将自动从url抓取并存储之后，所有的操作对用户透明，无须用户二次写入。并且memcache采取的lru-k算法，虽然降低了缓存污染的概率，但是由于算法本身的复杂性，需要维护一张节点访问次数历史表，花费一定空间与时间，lru-1虽然在面对偶发，周期性数据的批量数据，命中率较低，但在url环境下，我们更多应该考虑的是热点数据，无需使用空间与时间去换取有限的命中率。
</li></ul> 
</br>
<p /> <ul>
<li> 3. memcache内存池的分配规则，导致其在存储值的长度分布较为散列的数据时，数据丢失率增加，而ddcache因为对于不定长数据采取的是分割法，即用若干个定长（value_size）的数据，采用链表挂接的方法存储，因此在存储数据长度散列较为明显的情况下，也能保持高命中率。
</li></ul> 
</br>
<p /> <ul>
<li> 4. memcache由于要求服务场景的多适应性，设计了较为冗余的锁机制，具体如下 <ul>
<li> a. slabs lock全局锁，每次内存管理模块申请，释放内存，slab维护线程工作都需要获取slabs lock；
</li> <li> b. stats lock数据统计锁，每个工作线程各有单独的stats lock；
</li> <li> c. cache lock全局锁，内存中hash表的操作需持有该锁；
</li> <li> d. item lock锁，memcache创建大量的item lock锁，对k-v操作时，对k进行hash,然后取对应的item lock锁
</li> <li> <p style="font=5">其中：</p> <ul>
<li> a、b、d都是由于多个线程共享数据造成的
</li> <li> c是由于memcache的数据统计需要而产生 
</li></ul> 
</li> <li> 可以看到大多数锁都是由于多线程共享数据造成的，因此，如果线程单独享有一份数据，将大大减少锁的使用
</li> <li> ddcache正是采用的线程独享数据，每一个url被hash到不同的线程中，每个线程的数据各自独立，因此虽然服务器是多线程处理，但是每个数据只会被一个线程处理，而且并不会产生冗余数据
</li></ul> 
</li></ul> 
</br>
<h2><a name="对比测试"></a> <p style="color:red">对比测试</p> </h2>
<h3><a name="测试数据集"></a> 测试数据集 </h3> <ul>
<li> 将线上某台机器搜索日志107万进行顺序访问，搜索词58万，其中高命中率关键词（搜索次数大于等于10次）6631（大小为120M），搜索总数为35万，其余65万次访问，为低命中率关键词 memcache与ddcache分别使用120M最大空间，查看命中率情况
</li></ul> 
<h3><a name="测试参数"></a> 测试参数 </h3> <ul>
<li> ddcache启动参数ddcache -n 4 -p 8390 -v 1500 -s 4000 -b 600000 -k restart -m 30
</li> <li> memcache 启动参数 memcached -d -m 120（默认4个线程）
</li></ul> 
<h3><a name="测试结果"></a> 测试结果 </h3> <ul>
<li> <table width="500" height = "200" border="1"><tr><td>缓存/对比点</td><td>遍历时间</td><td>命中次数</td><td>命中率</td><td>内存分配</td><td>实用内存</td></tr><tr><td>memcache</td><td>13524s</td><td>368473</td><td>34%</td><td>122M</td><td>106M</td></tr><tr><td>ddcache</td><td>11402s         </td><td>356007</td><td>33%</td><td>120M</td><td>119M</td></tr></table>
</li></ul> 
<h3><a name="备注"></a> 备注 </h3> <ul>
<li> 内存分配是指cache已经分配了的空间，实用内存是指已经被用来做缓存数据的内存，在这一块上因为memcache的按value长度分配slab会导致其会有一部分闲置空间无法使用
</li></ul> 
<h3><a name="结果分析"></a> 结果分析 </h3> <ul>
<li> 可以看到ddcache因为减少了多线程锁，遍历时间会小于memcache,由于memcache使用的lru-k k&gt;=1算法，所以命中率稍微高些，但是可以看到提升并不是特别明显，内存分配如预期利用率偏低
</li></ul> 
</body>
<script type="text/javascript" src='http://sso.dangdang.com/Rbac/js_tracker.js'></script>
</html>
